--- 
title: Node.js Tutorial - Building a Chatroom with Express.js + Socket.IO
date: "2013-03-23T21:16:00.000-03:00"
author: William Mora
tags: 
- javascript
- curl
- socket.io
- rest
- underscore
- node.js
- jade
- web services
- json
- express
permalink: /2013/03/nodejs-tutorial-building-chatroom-with.html
---

In this tutorial we'll see the basics of creating a Node.js project with two of its most popular modules: Express.js and Socket.IO. We'll build a simple chatroom from scratch, like those from the early Internet days :P. <br /><br />The final code is on GitHub, here's the <a href="https://github.com/wmora/nodejs-express-socketio-chatroom">link</a>. <br /><br /><h2>Requirements</h2><br />We are going to be building the project from scratch, so the only requirement is that you install, of course, <a href="http://nodejs.org/">node</a> and <a href="https://npmjs.org/">npm</a> (if not included with node). Also, I assume you know JavaScript. If you don't, I totally recommend JavaScript's track at <a href="http://www.codecademy.com/">Codecademy</a>. <br /><br /><h2>Creating a Project</h2><br />Create the folder where we'll have our project, we'll be working from here from now on.  <br /><br />In Node, we don't really create a project with a specific folder structure, but create an app file instead; that is, the file that will be executed as the node application. You may name the file as you want; in most of the projects I've seen it named either app.js or server.js. Since we'll be building a web server, let's go with <code>server.js</code>. <br /><br />Let's make sure our node installation works properly. Put the following in <code>server.js</code>: <br /><pre>console.log("Hello, world!");<br /></pre>Now, run your app. From a terminal window, execute: <br /><pre>$ node server.js<br /></pre>You should see the output: <br /><pre>Hello, world!<br /></pre>Ok, good to go! Now, create a file called <code>package.json</code>.This file serves the purpose of packaging your node project. Here you can specify the project name, author(s) info, dependency modules, node version, etc. There's an excellent <a href="http://package.json.nodejitsu.com/">cheat sheet</a> that you can use to package your own project. <br /><br />For this project, the only info that you need in your <code>package.json</code> file is the following: <br /><pre>{<br />  "dependencies": {<br />    "express": "4.6.1",<br />    "jade": "1.4.2",<br />    "socket.io": "1.0.6",<br />    "underscore": "1.6.0",<br />    "body-parser": "1.4.3"<br />  }<br />}<br /></pre>You can put as much info as you like; the more info you put, the more info you are giving others about your app. The dependencies object is used by <code>npm</code> to download any necessary external modules for your app. Let's go briefly through each one: <br /><ul><li><b><a href="http://expressjs.com/">Express</a>:</b> a web framework for node. It is one of the most used modules in node.js; it takes care of a lot of <a href="http://en.wikipedia.org/wiki/Boilerplate_code">boilerplate code</a> to build a web app. If you are using views in your project, it expects you to use a template engine. By default, it expects <code>Jade</code> to be used.</li><li><b><a href="http://jade-lang.com/">Jade</a></b>: a template engine for node. If you know HTML, you'll love Jade. Briefly go through the docs and you'll see what I mean.</li><li><b><a href="http://socket.io/">Socket.IO</a>:</b> a module that makes real-time apps possible. We'll go into more detail later in this tutorial.</li><li><b><a href="http://underscorejs.org/">Underscore</a>:</b> a utility module that has many common operations that you would normally use in other dynamic languages like <a href="http://groovy.codehaus.org/">Groovy</a> or <a href="http://www.ruby-lang.org/">Ruby</a>.</li><li><a href="https://github.com/expressjs/body-parser" style="font-weight: bold;" target="_blank">Body Parser</a><b>: </b>middleware parsing utility for node. We'll use this to let the server parse JSON requests</li></ul>Now that we've included our dependencies for the project, let's tell <code>npm</code> to install the binaries: <br /><pre>$ npm install<br /></pre><code>Npm</code> will automatically read the <code>package.json</code> file and download the dependencies noted in it. The output should be similar to the following: <br /><pre>&gt; ws@0.4.31 install /node_modules/socket.io/node_modules/engine.io/node_modules/ws<br />&gt; (node-gyp rebuild 2&gt; builderror.log) || (exit 0)<br /><br />  CXX(target) Release/obj.target/bufferutil/src/bufferutil.o<br />  SOLINK_MODULE(target) Release/bufferutil.node<br />  SOLINK_MODULE(target) Release/bufferutil.node: Finished<br />  CXX(target) Release/obj.target/validation/src/validation.o<br />  SOLINK_MODULE(target) Release/validation.node<br />  SOLINK_MODULE(target) Release/validation.node: Finished<br /><br />&gt; ws@0.4.31 install /node_modules/socket.io/node_modules/socket.io-client/node_modules/engine.io-client/node_modules/ws<br />&gt; (node-gyp rebuild 2&gt; builderror.log) || (exit 0)<br /><br />  CXX(target) Release/obj.target/bufferutil/src/bufferutil.o<br />  SOLINK_MODULE(target) Release/bufferutil.node<br />  SOLINK_MODULE(target) Release/bufferutil.node: Finished<br />  CXX(target) Release/obj.target/validation/src/validation.o<br />  SOLINK_MODULE(target) Release/validation.node<br />  SOLINK_MODULE(target) Release/validation.node: Finished<br />underscore@1.6.0 node_modules/underscore<br /><br />body-parser@1.4.3 node_modules/body-parser<br />├── qs@0.6.6<br />├── media-typer@0.2.0<br />├── bytes@1.0.0<br />├── raw-body@1.2.2<br />├── depd@0.3.0<br />├── iconv-lite@0.4.3<br />└── type-is@1.3.1 (mime-types@1.0.0)<br /><br />express@4.6.1 node_modules/express<br />├── utils-merge@1.0.0<br />├── merge-descriptors@0.0.2<br />├── parseurl@1.1.3<br />├── cookie@0.1.2<br />├── escape-html@1.0.1<br />├── finalhandler@0.0.3<br />├── cookie-signature@1.0.4<br />├── range-parser@1.0.0<br />├── fresh@0.2.2<br />├── vary@0.1.0<br />├── qs@0.6.6<br />├── media-typer@0.2.0<br />├── methods@1.1.0<br />├── serve-static@1.3.2<br />├── buffer-crc32@0.2.3<br />├── depd@0.3.0<br />├── path-to-regexp@0.1.3<br />├── accepts@1.0.7 (negotiator@0.4.7, mime-types@1.0.1)<br />├── type-is@1.3.2 (mime-types@1.0.1)<br />├── proxy-addr@1.0.1 (ipaddr.js@0.1.2)<br />├── debug@1.0.3 (ms@0.6.2)<br />└── send@0.6.0 (ms@0.6.2, mime@1.2.11, finished@1.2.2)<br /><br />socket.io@1.0.6 node_modules/socket.io<br />├── debug@0.7.4<br />├── has-binary-data@0.1.1 (isarray@0.0.1)<br />├── socket.io-parser@2.2.0 (isarray@0.0.1, emitter@1.0.1, json3@3.2.6)<br />├── socket.io-adapter@0.2.0 (socket.io-parser@2.1.2)<br />├── engine.io@1.3.1 (base64id@0.1.0, debug@0.6.0, engine.io-parser@1.0.6, ws@0.4.31)<br />└── socket.io-client@1.0.6 (to-array@0.1.3, indexof@0.0.1, component-bind@1.0.0, object-component@0.0.3, component-emitter@1.1.2, parseuri@0.0.2, engine.io-client@1.3.1)<br /><br />jade@1.4.2 node_modules/jade<br />├── commander@2.1.0<br />├── character-parser@1.2.0<br />├── mkdirp@0.5.0 (minimist@0.0.8)<br />├── transformers@2.1.0 (promise@2.0.0, css@1.0.8, uglify-js@2.2.5)<br />├── with@3.0.0 (uglify-js@2.4.15)<br />├── constantinople@2.0.1 (uglify-js@2.4.15)<br />└── monocle@1.1.51 (readdirp@0.2.5)<br /></pre>You should now have a folder named <code>node_modules</code>. The folder contains all the necessary files and binaries to run your project. This means that now this folder is truly the root folder of your project. <br /><br /><h2>HTTP Server Setup</h2><br />To set up the HTTP server using Express, we also need the <code><a href="http://nodejs.org/api/http.html">http</a></code> module included with node. You can go through the <a href="http://nodejs.org/api/">node documentation</a> to see other modules included with it. Let's change the contents of <code>server.js</code> as follows: <br /><i><b>NOTE</b>: I'll comment where necessary; otherwise, it should be self-explanatory.</i><br /><pre>/* <br />  Module dependencies:<br />  <br />  - Express<br />  - Http (to run Express)<br />  - Body parser (to parse JSON requests)<br /><br />  It is a common practice to name the variables after the module name.<br />  Ex: http is the "http" module, express is the "express" module, etc.<br />*/<br />var express = require("express")<br />  , app = express()<br />  , http = require("http").createServer(app)<br />  , bodyParser = require("body-parser");<br /><br />/* Server config */<br /><br />//Server's IP address<br />app.set("ipaddr", "127.0.0.1");<br /><br />//Server's port number <br />app.set("port", 8080);<br /><br />//Tells server to support JSON requests<br />app.use(bodyParser.json());<br /><br />/* Server routing */<br /><br />//Handle route "GET /", as in "http://localhost:8080/"<br />app.get("/", function(request, response) {<br /><br />  //Show a simple response message<br />  response.send("Server is up and running");<br /><br />});<br /><br />//Start the http server at port and IP defined before<br />http.listen(app.get("port"), app.get("ipaddr"), function() {<br />  console.log("Server up and running. Go to http://" + app.get("ipaddr") + ":" + app.get("port"));<br />});<br /></pre>Start the server: <br /><pre>$ node server.js<br /></pre>You should see the message: <br /><pre>Server up and running. Go to http://127.0.0.1:8080<br /></pre>If you go to that address in a browser, you should see a message as follows: <br /><br /><a href="http://1.bp.blogspot.com/-Fe8MZ0UBR6c/UU3dlcaDRhI/AAAAAAAAB9o/_a5yYoYmcDA/s1600/image-1.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-Fe8MZ0UBR6c/UU3dlcaDRhI/AAAAAAAAB9o/_a5yYoYmcDA/s320/image-1.png" /></a><br /><br />Awesome! We have an HTTP server up and running. Granted, it doesn't do much but if you have worked with other web frameworks, you have to admit that it was very easy to set up an HTTP server. If you wanted to use an HTTPS server instead, instead of using the <code><a href="http://nodejs.org/api/http.html">http</a></code> module you would use the <code><a href="http://nodejs.org/api/https.html">https</a></code> module instead. Yup, is that easy. <br /><br /><h2>Building a Jade View</h2><br />This is a two-step process. First we have to tell our server that we are using Jade as our template engine. Then, we'll create the view of our chatroom. <br /><br />Add folders to our project where we'll have all static content (css, client javascript), and one folder with our jade templates, or views. Add the following folder structure to the project: <br /><pre>public/<br />├── js/<br />└── css/<br /><br />views/<br /></pre>Let the server know about this folder. Stop the server if you haven't already done so and modify <code>server.js</code>: <br /><i><b>NOTE</b>: Changes in <b>bold</b>.</i><br /><pre>/* <br />  Module dependencies:<br />  <br />  - Express<br />  - Http (to run Express)<br />  - Body parser (to parse JSON requests)<br />  <br />  It is a common practice to name the variables after the module name.<br />  Ex: http is the "http" module, express is the "express" module, etc.<br />*/<br />var express = require("express")<br />  , app = express()<br />  , http = require("http").createServer(app)<br />  , bodyParser = require("body-parser");<br /><br />/* Server config */<br /><br />//Server's IP address<br />app.set("ipaddr", "127.0.0.1");<br /><br />//Server's port number <br />app.set("port", 8080);<br /><b><br />//Specify the views folder<br />app.set("views", __dirname + "/views");<br /><br />//View engine is Jade<br />app.set("view engine", "jade");<br /><br />//Specify where the static content is<br />app.use(express.static("public", __dirname + "/public"));<br /></b><br />//Tells server to support JSON requests<br />app.use(bodyParser.json());<br /><br />/* Server routing */<br /><br />//Handle route "GET /", as in "http://localhost:8080/"<br />app.get("/", function(request, response) {<br /><b><br />  //Render the view called "index"<br />  response.render("index");<br /></b><br />});<br /><br />//Start the http server at port and IP defined before<br />http.listen(app.get("port"), app.get("ipaddr"), function() {<br />  console.log("Server up and running. Go to http://" + app.get("ipaddr") + ":" + app.get("port"));<br />});<br /></pre>Great! Now our server is ready to display views. The only thing missing is an actual view! Under the <code>views</code> folder, create a file named <code>index.jade</code>. This is the view we are telling the server to render when accessing <code>http://localhost:8080</code>. At this point you should probably take a quick look at the <a href="https://github.com/visionmedia/jade#readme">Jade documentation</a> but if you don't feel like it, don't worry, I'll create a simple document and the Jade syntax should be self-explanatory. The contents of <code>index.jade</code> should be the following: <br /><pre>doctype html<br />html<br />  head<br />    link(rel='stylesheet', href='http://fonts.googleapis.com/css?family=Open+Sans')<br />    link(rel='stylesheet', href='/css/style.css')    <br />    title Super Awesome Chatroom<br />  body<br />    h1 Super Awesome Chatroom<br />    div<br />      div.inlineBlock<br />        span Your name:<br />          input(type="text", value="Anonymous")#name<br />        br<br />        form#messageForm<br />          textarea(rows="4", cols="50", placeholder="Share something!", maxlength=200)#outgoingMessage<br />          input(type="button", value="Share", disabled=true)#send<br />      div.inlineBlock.topAligned<br />        b Participants<br />        br<br />        div#participants<br />    div#messages<br /></pre>I'd like to point out that Jade is awesome, I think the documents look way more elegant like this as opposed to simple HTML. Anyhow, we also need to create a stylesheet for the classes we assigned to some of the elements. It should be named <code>style.css</code> under the folder <code>public/css/</code> with the following: <br /><i><b>NOTE</b>: If you decide to name the file other than style.css just make sure you also change it in index.jade.</i><br /><pre>body {<br />  padding: 3em;<br />  font-family: 'Open Sans', sans-serif;<br />  font-size: 1em;<br />}<br /><br />textarea {<br />  resize: none;<br />}<br /><br />.inlineBlock {<br /> display: inline-block;<br />}<br /><br />.topAligned {<br /> vertical-align: top;<br />}<br /></pre>We have our view! Start (or restart) the server, open the browser and go to <code>http://localhost:8080</code>. You should now see an awesome chatroom that doesn't do anything (yet!) like the one in the picture: <br /><br /><a href="http://4.bp.blogspot.com/-ChMarh-70to/UU4ARX2t62I/AAAAAAAAB94/tOLemWj-Ur8/s1600/image-2.png" imageanchor="1"><img border="0" src="http://4.bp.blogspot.com/-ChMarh-70to/UU4ARX2t62I/AAAAAAAAB94/tOLemWj-Ur8/s320/image-2.png" /></a><br /><br /><h2>Web Services with Express</h2><br />Express is great for creating <a href="http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services">RESTful web services</a>. From the frameworks I've worked with, it has to be one of the easiest, if not the easiest, to build them with. If you take a look at <code>server.js</code> you'll notice we have the following function to render our view: <br /><pre>//Handle route "GET /", as in "http://localhost:8080/"<br />app.get("/", function(request, response) {<br /><br />  //Render the view called "index"<br />  response.render("index");<br /><br />});<br /></pre>We could easily change a function like the following: <br /><pre>//Handle route "GET /", as in "http://localhost:8080/"<br />app.get("/", function(request, response) {<br /><br />  //Return what's on your mind<br />  response.json(200, {message: "express is cool"});<br /><br />});<br /></pre>And that would create a GET service at "http://localhost:8080/" that returns a JSON object. Awesome! Isn't it? Let's add a POST method to our <code>server.js</code> to send a chat message. We will also begin using Underscore; : <br /><i><b>NOTE</b>: Changes in <b>bold</b>.</i><br /><pre>/* <br />  Module dependencies:<br />  <br />  - Express<br />  - Http (to run Express)<br />  - Body parser (to parse JSON requests)<br />  - Underscore (because it's cool)<br />  <br />  It is a common practice to name the variables after the module name.<br />  Ex: http is the "http" module, express is the "express" module, etc.<b><br />  The only exception is Underscore, where we use, conveniently, an underscore.</b><br /><br />*/<br />var express = require("express")<br />  , app = express()<br />  , http = require("http").createServer(app)<br />  , bodyParser = require("body-parser")<br /><b>  , _ = require("underscore");</b><br /><br />/* Server config */<br /><br />//Server's IP address<br />app.set("ipaddr", "127.0.0.1");<br /><br />//Server's port number <br />app.set("port", 8080);<br /><br />//Specify the views folder<br />app.set("views", __dirname + "/views");<br /><br />//View engine is Jade<br />app.set("view engine", "jade");<br /><br />//Specify where the static content is<br />app.use(express.static("public", __dirname + "/public"));<br /><br />//Tells server to support JSON requests<br />app.use(bodyParser.json());<br /><br />/* Server routing */<br /><br />//Handle route "GET /", as in "http://localhost:8080/"<br />app.get("/", function(request, response) {<br /><br />  //Render the view called "index"<br />  response.render("index");<br /><br />});<br /><b><br />//POST method to create a chat message<br />app.post("/message", function(request, response) {<br /><br />  //The request body expects a param named "message"<br />  var message = request.body.message;<br /><br />  //If the message is empty or wasn't sent it's a bad request<br />  if(_.isUndefined(message) || _.isEmpty(message.trim())) {<br />    return response.json(400, {error: "Message is invalid"});<br />  }<br /><br />  //Looks good, let the client know<br />  response.json(200, {message: "Message received"});<br /><br />});<br /></b><br />//Start the http server at port and IP defined before<br />http.listen(app.get("port"), app.get("ipaddr"), function() {<br />  console.log("Server up and running. Go to http://" + app.get("ipaddr") + ":" + app.get("port"));<br />});<br /></pre>Let's test our POST method, (re)start the server and call the method at <code>http://localhost:8080/message</code>. I'm using <code>curl</code> as my REST client, but you can choose whichever you want. <br /><pre>$ curl -X POST -H 'Content-Type:application/json' 'http://localhost:8080/message' -d '{"message":"Good news, everyone!"}'<br />{<br />  "message": "Message received"<br />}<br /></pre>Let's test a bad request. <br /><pre>$ curl -X POST -H 'Content-Type:application/json' 'http://localhost:8080/message' -d '{"invalidParam":"Good news, everyone!"}'<br />{<br />  "error": "Message is invalid"<br />}<br />$ curl -X POST -H 'Content-Type:application/json' 'http://localhost:8080/message' -d '{"message":""}'<br />{<br />  "error": "Message is invalid"<br />}<br /></pre>This is as far as we'll go with RESTful services in this tutorial, but feel free to browse through the <a href="http://expressjs.com/api.html">Express documentation</a> and build more methods or add options to our POST method. <br /><br /><h2>Making real-time apps with Socket.IO</h2><br />So far we have a web server that receives incoming messages that does nothing with them, and a view that can't even send a message. I think that now it's a good time to make this a real-time app. Let's talk a little bit about Socket.IO first. <br /><br />Socket.IO is a module that aims at making real-time apps possible. Long story short, it consists of a server that receives and emits events to all the clients, or just a set of clients, that connect to it. Here's a list of <a href="http://socket.io/#browser-support">browser and transport support</a> for it. There are many websites that use Socket.IO, however, an excellent implementation of it is <a href="https://trello.com/">Trello</a>. Fog Creek Software, its creator, have an excellent <a href="http://blog.fogcreek.com/the-trello-tech-stack/">post</a> on the website's tech stack, including comments on their implementation of Socket.IO. It is definitely worth a read. <br /><br />We are going to set up our socket server with our web server, but if you are considering building a huge website you should definitely implement your socket.IO server as a dedicated service instead of mixing it with your web server. Modify the header of <code>server.js</code> with the following: <br /><i><b>NOTE</b>: Changes in <b>bold</b>.</i><br /><pre>/* <br />  Module dependencies:<br />  <br />  - Express<br />  - Http (to run Express)<br />  - Body parser (to parse JSON requests)<br />  - Underscore (because it's cool)<br /><b>  - Socket.IO(Note: we need a web server to attach Socket.IO to)</b><br />  <br />  It is a common practice to name the variables after the module name.<br />  Ex: http is the "http" module, express is the "express" module, etc.<br />  The only exception is Underscore, where we use, conveniently, an <br />  underscore. <b>Oh, and "socket.io" is simply called io. Seriously, the <br />  rest should be named after its module name.</b><br /><br />*/<br />var express = require("express")<br />  , app = express()<br />  , http = require("http").createServer(app)<br />  , bodyParser = require("body-parser")<b><br />  , io = require("socket.io").listen(http)</b><br />  , _ = require("underscore");<br /><br />/* Server config */<br />...<br /></pre>Yup, we now have a socket.IO server up and running at the same location as our web server (<code>http://localhost:8080</code>). Let's test it, shall we? For development purposes, socket.IO serves its client library at <code>/socket.io/socket.io.js</code>. Let's also go ahead and create a JavaScript file that will be used in our client. Name it <code>index.js</code> (or whatever you like, just make sure it's called the same in your <code>index.jade</code> file) and add it to our static location of JavaScript files,&nbsp;<code>public/js/</code>. Finally, we'll use <a href="http://jquery.com/">jQuery</a> for our client code, so we'll use it with a&nbsp;<a href="http://en.wikipedia.org/wiki/Content_delivery_network" target="_blank">CDN</a>&nbsp;(this example works with version 1.11). Modify the <code>head</code> tag of <code>index.jade</code> so it includes all JavaScript files, <code>socket.io.js</code>, <code>jquery-1.11.0.min.js</code> and <code>index.js</code>:<br /><i><b>NOTE</b>: Changes in <b>bold</b>.</i><br /><pre>doctype html<br />html<br />  head<br />    link(rel='stylesheet', href='http://fonts.googleapis.com/css?family=Open+Sans')<br />    link(rel='stylesheet', href='/css/style.css') <b>   <br />    script(src='//code.jquery.com/jquery-1.11.0.min.js')<br />    script(src='/socket.io/socket.io.js')<br />    script(src='/js/index.js')</b><br />    title Super Awesome Chatroom<br />  body<br />    ...<br /></pre>Let's put the following in <code>index.js</code>: <br /><i><b>NOTE</b>: I'll comment where necessary; otherwise, it should be self-explanatory. Also, I'm not going to explain jQuery, you can go to <a href="http://www.codecademy.com/">Codecademy</a> for that. They've got excellent tutorials.</i><br /><pre>function init() {<br /><br />  var serverBaseUrl = document.domain;<br /><br />  /* <br />   On client init, try to connect to the socket.IO server.<br />   Note we don't specify a port since we set up our server<br />   to run on port 8080<br />  */<br />  var socket = io.connect(serverBaseUrl);<br /><br />  //We'll save our session ID in a variable for later<br />  var sessionId = '';<br /><br />  /*<br /> When the client successfully connects to the server, an<br /> event "connect" is emitted. Let's get the session ID and<br /> log it.<br />  */<br />  socket.on('connect', function () {<br />    sessionId = socket.io.engine.id;<br />    console.log('Connected ' + sessionId);    <br />  });<br />}<br /><br />$(document).on('ready', init);<br /></pre>Let's test it! (Re)start the server, as soon as you start the server you should see an info message from the socket.IO server: <br /><pre>$ node server.js <br />Server up and running. Go to http://127.0.0.1:8080<br /></pre>Open the browser and go to <code>http://localhost:8080</code>. Take a look at the browser console and you should see the log along with a session ID as follows: <br /><pre>Connected b0mT1Y370LFMU7rKXTsP<br /></pre>Woohoo! We now have a socket.IO server along out web server and successfully connected a client to it. We can now finish our chatroom! <br /><br /><h2>A Chatroom</h2><br />Let's use what we just did to finish our chatroom. We are going to be working with the following events between our client and server: <br /><ul><li>When a new user connects to our server, he will emit an event called <code><b>newUser</b></code> and the server will emit an event called <code><b>newConnection</b></code> with a list of all participants to all connected clients</li><li>When a user changes his name, he will emit an event called <code><b>nameChange</b></code> and the server will emit an event called <code><b>nameChanged</b></code> to all participants with the id and new name of the user who emitted the original message</li><li>When a client disconnects from the server, an event called <code><b>disconnect</b></code> is automatically captured by the server. It will then emit an event to all participants with the id of the client that disconnected</li><li>When a client sends a message through our POST method, the server will emit an event called <code><b>incomingMessage</b></code> which will send the sender's name and the message to all clients to show on their views</li></ul>Let's add all this fancy stuff to our server. This is the final version of <code>server.js</code>: <br /><i><b>NOTE</b>: Changes in <b>bold</b>.</i><br /><pre>/* <br />  Module dependencies:<br />  <br />  - Express<br />  - Http (to run Express)<br />  - Body parser (to parse JSON requests)<br />  - Underscore (because it's cool)<br />  - Socket.IO<br />  <br />  It is a common practice to name the variables after the module name.<br />  Ex: http is the "http" module, express is the "express" module, etc.<br />  The only exception is Underscore, where we use, conveniently, an <br />  underscore. Oh, and "socket.io" is simply called io. Seriously, the <br />  rest should be named after its module name.<br /><br />*/<br />var express = require("express")<br />  , app = express()<br />  , http = require("http").createServer(app)<br />  , bodyParser = require("body-parser")<br />  , io = require("socket.io").listen(http)<br />  , _ = require("underscore");<br /><b><br />/* <br />  The list of participants in our chatroom.<br />  The format of each participant will be:<br />  {<br />    id: "sessionId",<br />    name: "participantName"<br />  }<br />*/<br />var participants = [];<br /></b><br />/* Server config */<br /><br />//Server's IP address<br />app.set("ipaddr", "127.0.0.1");<br /><br />//Server's port number <br />app.set("port", 8080);<br /><br />//Specify the views folder<br />app.set("views", __dirname + "/views");<br /><br />//View engine is Jade<br />app.set("view engine", "jade");<br /><br />//Specify where the static content is<br />app.use(express.static("public", __dirname + "/public"));<br /><br />//Tells server to support JSON requests<br />app.use(bodyParser.json());<br /><br />/* Server routing */<br /><br />//Handle route "GET /", as in "http://localhost:8080/"<br />app.get("/", function(request, response) {<br /><br />  //Render the view called "index"<br />  response.render("index");<br /><br />});<br /><br />//POST method to create a chat message<br />app.post("/message", function(request, response) {<br /><br />  //The request body expects a param named "message"<br />  var message = request.body.message;<br /><br />  //If the message is empty or wasn't sent it's a bad request<br />  if(_.isUndefined(message) || _.isEmpty(message.trim())) {<br />    return response.json(400, {error: "Message is invalid"});<br />  }<br /><b><br />  //We also expect the sender's name with the message<br />  var name = request.body.name;<br /><br />  //Let our chatroom know there was a new message<br />  io.sockets.emit("incomingMessage", {message: message, name: name});<br /></b><br />  //Looks good, let the client know<br />  response.json(200, {message: "Message received"});<br /><br />});<br /><b><br />/* Socket.IO events */<br />io.on("connection", function(socket){<br />  <br />  /*<br />    When a new user connects to our server, we expect an event called "newUser"<br />    and then we'll emit an event called "newConnection" with a list of all <br />    participants to all connected clients<br />  */<br />  socket.on("newUser", function(data) {<br />    participants.push({id: data.id, name: data.name});<br />    io.sockets.emit("newConnection", {participants: participants});<br />  });<br /><br />  /*<br />    When a user changes his name, we are expecting an event called "nameChange" <br />    and then we'll emit an event called "nameChanged" to all participants with<br />    the id and new name of the user who emitted the original message<br />  */<br />  socket.on("nameChange", function(data) {<br />    _.findWhere(participants, {id: socket.id}).name = data.name;<br />    io.sockets.emit("nameChanged", {id: data.id, name: data.name});<br />  });<br /><br />  /* <br />    When a client disconnects from the server, the event "disconnect" is automatically <br />    captured by the server. It will then emit an event called "userDisconnected" to <br />    all participants with the id of the client that disconnected<br />  */<br />  socket.on("disconnect", function() {<br />    participants = _.without(participants,_.findWhere(participants, {id: socket.id}));<br />    io.sockets.emit("userDisconnected", {id: socket.id, sender:"system"});<br />  });<br /><br />});<br /></b><br />//Start the http server at port and IP defined before<br />http.listen(app.get("port"), app.get("ipaddr"), function() {<br />  console.log("Server up and running. Go to http://" + app.get("ipaddr") + ":" + app.get("port"));<br />});<br /></pre>I think the code and the comments are self-explanatory. If not, let me know in the comments section to update it accordingly. <br /><br />Let's finish this chatroom by extending the <code>index.js</code> file with the events we just defined. <br /><i><b>NOTE</b>: Changes in <b>bold</b>.</i><br /><pre>function init() {<br /><br />  var serverBaseUrl = document.domain;<br /><br />  /* <br />   On client init, try to connect to the socket.IO server.<br />   Note we don't specify a port since we set up our server<br />   to run on port 8080<br />  */<br />  var socket = io.connect(serverBaseUrl);<br /><br />  //We'll save our session ID in a variable for later<br />  var sessionId = '';<br /><br />  //Helper function to update the participants' list<br />  function updateParticipants(participants) {<br />   $('#participants').html('');<br />   for (var i = 0; i &lt; participants.length; i++) {<br />      $('#participants').append('&lt;span id="' + participants[i].id + '"&gt;' +<br />        participants[i].name + ' ' + (participants[i].id === sessionId ? '(You)' : '') + '&lt;br /&gt;&lt;/span&gt;');<br />    } <br />  }<br /><br />  /*<br /> When the client successfully connects to the server, an<br /> event "connect" is emitted. Let's get the session ID and<br /> log it.<b> Also, let the socket.IO server there's a new user<br /> with a session ID and a name. We'll emit the "newUser" event<br /> for that.</b> <br />  */<br />  socket.on('connect', function () {<br />    sessionId = socket.io.engine.id;<br />    console.log('Connected ' + sessionId);<b><br />    socket.emit('newUser', {id: sessionId, name: $('#name').val()});</b><br />  });<br /><b><br />  /*<br /> When the server emits the "newConnection" event, we'll reset<br /> the participants section and display the connected clients. <br /> Note we are assigning the sessionId as the span ID.<br />  */<br />  socket.on('newConnection', function (data) {    <br />    updateParticipants(data.participants);<br />  });<br /><br />  /*<br /> When the server emits the "userDisconnected" event, we'll<br /> remove the span element from the participants element<br />  */<br />  socket.on('userDisconnected', function(data) {<br />    $('#' + data.id).remove();<br />  });<br /><br />  /*<br /> When the server fires the "nameChanged" event, it means we<br /> must update the span with the given ID accordingly<br />  */<br />  socket.on('nameChanged', function (data) {<br />    $('#' + data.id).html(data.name + ' ' + (data.id === sessionId ? '(You)' : '') + '&lt;br /&gt;');<br />  });<br /><br />  /*<br /> When receiving a new chat message with the "incomingMessage" event,<br /> we'll prepend it to the messages section<br />  */<br />  socket.on('incomingMessage', function (data) {<br />    var message = data.message;<br />    var name = data.name;<br />    $('#messages').prepend('&lt;b&gt;' + name + '&lt;/b&gt;&lt;br /&gt;' + message + '&lt;hr /&gt;');<br />  });<br /><br />  /*<br /> Log an error if unable to connect to server<br />  */<br />  socket.on('error', function (reason) {<br />    console.log('Unable to connect to server', reason);<br />  });<br /><br />  /*<br /> "sendMessage" will do a simple ajax POST call to our server with<br /> whatever message we have in our textarea<br />  */<br />  function sendMessage() {<br />    var outgoingMessage = $('#outgoingMessage').val();<br />    var name = $('#name').val();<br />    $.ajax({<br />      url:  '/message',<br />      type: 'POST',<br />      contentType: 'application/json',<br />      dataType: 'json',<br />      data: JSON.stringify({message: outgoingMessage, name: name})<br />    });<br />  }<br /><br />  /*<br /> If user presses Enter key on textarea, call sendMessage if there<br /> is something to share<br />  */<br />  function outgoingMessageKeyDown(event) {<br />    if (event.which == 13) {<br />      event.preventDefault();<br />      if ($('#outgoingMessage').val().trim().length &lt;= 0) {<br />        return;<br />      }<br />      sendMessage();<br />      $('#outgoingMessage').val('');<br />    }<br />  }<br /><br />  /*<br /> Helper function to disable/enable Send button<br />  */<br />  function outgoingMessageKeyUp() {<br />    var outgoingMessageValue = $('#outgoingMessage').val();<br />    $('#send').attr('disabled', (outgoingMessageValue.trim()).length &gt; 0 ? false : true);<br />  }<br /><br />  /*<br /> When a user updates his/her name, let the server know by<br /> emitting the "nameChange" event<br />  */<br />  function nameFocusOut() {<br />    var name = $('#name').val();<br />    socket.emit('nameChange', {id: sessionId, name: name});<br />  }<br /><br />  /* Elements setup */<br />  $('#outgoingMessage').on('keydown', outgoingMessageKeyDown);<br />  $('#outgoingMessage').on('keyup', outgoingMessageKeyUp);<br />  $('#name').on('focusout', nameFocusOut);<br />  $('#send').on('click', sendMessage);<br /></b><br />}<br /><br />$(document).on('ready', init);<br /></pre>Aaaaaand, that's it! (Re)start the server and see our chatroom in action! <br /><pre>$ node server.js <br />Server up and running. Go to http://127.0.0.1:8080<br /></pre>Let's open a browser to <code>http://localhost:8080</code>. You should see the following: <br /><br /><a href="http://2.bp.blogspot.com/-RXw-RHAvwWQ/UU4-pKyf_SI/AAAAAAAAB-Q/m0LfWCHhjMs/s1600/image-3.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-RXw-RHAvwWQ/UU4-pKyf_SI/AAAAAAAAB-Q/m0LfWCHhjMs/s320/image-3.png" /></a><br /><br />Now, open another tab or window at the same address: <br /><a href="http://3.bp.blogspot.com/-Zfjx-VmWk1Y/UU4-oilZxUI/AAAAAAAAB-I/vuq926RR_uU/s1600/image-4.png" imageanchor="1"><img border="0" src="http://3.bp.blogspot.com/-Zfjx-VmWk1Y/UU4-oilZxUI/AAAAAAAAB-I/vuq926RR_uU/s320/image-4.png" /></a><br /><br />You should see the list of participants on both sessions. Now change the name of one of the users: <br /><a href="http://1.bp.blogspot.com/-_LMqJ3YpHv4/UU4-pRFFoOI/AAAAAAAAB-Y/qIAFY7H5jQM/s1600/image-5.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-_LMqJ3YpHv4/UU4-pRFFoOI/AAAAAAAAB-Y/qIAFY7H5jQM/s320/image-5.png" /></a><br /><br />All sessions should reflect the change: <br /><a href="http://3.bp.blogspot.com/-PBCjuKrrFYI/UU4-phajAiI/AAAAAAAAB-c/vLh-y7PYw1U/s1600/image-6.png" imageanchor="1"><img border="0" src="http://3.bp.blogspot.com/-PBCjuKrrFYI/UU4-phajAiI/AAAAAAAAB-c/vLh-y7PYw1U/s320/image-6.png" /></a><br /><br />Send a message from one of the sessions: <br /><a href="http://2.bp.blogspot.com/-zQf-z1Dw3U8/UU4-rAxD8XI/AAAAAAAAB-o/PfF4uaZiz4M/s1600/image-7.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-zQf-z1Dw3U8/UU4-rAxD8XI/AAAAAAAAB-o/PfF4uaZiz4M/s320/image-7.png" /></a><br /><br />Check the other session to see the message that was sent: <br /><a href="http://1.bp.blogspot.com/-KxY0g8PGNkY/UU4-rcFwNgI/AAAAAAAAB-s/zeMY5SL2HXU/s1600/image-8.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/-KxY0g8PGNkY/UU4-rcFwNgI/AAAAAAAAB-s/zeMY5SL2HXU/s320/image-8.png" /></a><br /><br />Finally, send a message back to the other session: <br /><a href="http://2.bp.blogspot.com/-lEbbeXrzS28/UU4-rpfM49I/AAAAAAAAB-4/IHJcdxYZxC0/s1600/image-9.png" imageanchor="1"><img border="0" src="http://2.bp.blogspot.com/-lEbbeXrzS28/UU4-rpfM49I/AAAAAAAAB-4/IHJcdxYZxC0/s320/image-9.png" /></a><br /><br />Your super awesome chatroom is now complete! Note that this is a very basic implementation of different node modules, and also know that this chatroom is vulnerable to XSS and you should at the very least add an HTML sanitizer if you intend to use it for a real-world application.  <br /><br />What I would like now is for you to be creative and add events, styles, and cool functionalities to the chatroom. Share them all in the comments section or let everyone know what you thought of this tutorial! <br /><br />Thanks for reading this far, I put a lot of effort into making this tutorial. If you liked it, I would really appreciate it if you could help spread the word by sharing this post.